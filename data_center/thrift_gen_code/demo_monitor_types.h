/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef demo_monitor_TYPES_H
#define demo_monitor_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace demomonitor {

struct METRIC {
  enum type {
    CPU_SYS = 0,
    CPU_USR = 1,
    RAM_PHYSIC = 2,
    RAM_SWAP = 3,
    DISK_READ = 4,
    DISK_WRITE = 5,
    DISK_FREE = 6,
    NET_IN = 7,
    NET_OUT = 8
  };
};

extern const std::map<int, const char*> _METRIC_VALUES_TO_NAMES;

struct TAG {
  enum type {
    CPU = 0,
    RAM = 1,
    DISK = 2,
    NET = 3
  };
};

extern const std::map<int, const char*> _TAG_VALUES_TO_NAMES;

class dataCollector;

class InvalidIOOperator;

typedef struct _dataCollector__isset {
  _dataCollector__isset() : metric(false), tag(false), object(false), value(false) {}
  bool metric :1;
  bool tag :1;
  bool object :1;
  bool value :1;
} _dataCollector__isset;

class dataCollector {
 public:

  dataCollector(const dataCollector&);
  dataCollector& operator=(const dataCollector&);
  dataCollector() : metric((METRIC::type)0), tag((TAG::type)0), object(), value(0) {
  }

  virtual ~dataCollector() throw();
  METRIC::type metric;
  TAG::type tag;
  std::string object;
  double value;

  _dataCollector__isset __isset;

  void __set_metric(const METRIC::type val);

  void __set_tag(const TAG::type val);

  void __set_object(const std::string& val);

  void __set_value(const double val);

  bool operator == (const dataCollector & rhs) const
  {
    if (!(metric == rhs.metric))
      return false;
    if (!(tag == rhs.tag))
      return false;
    if (!(object == rhs.object))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const dataCollector &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const dataCollector & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(dataCollector &a, dataCollector &b);

inline std::ostream& operator<<(std::ostream& out, const dataCollector& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _InvalidIOOperator__isset {
  _InvalidIOOperator__isset() : iwhat(false), swhy(false) {}
  bool iwhat :1;
  bool swhy :1;
} _InvalidIOOperator__isset;

class InvalidIOOperator : public ::apache::thrift::TException {
 public:

  InvalidIOOperator(const InvalidIOOperator&);
  InvalidIOOperator& operator=(const InvalidIOOperator&);
  InvalidIOOperator() : iwhat(0), swhy() {
  }

  virtual ~InvalidIOOperator() throw();
  int32_t iwhat;
  std::string swhy;

  _InvalidIOOperator__isset __isset;

  void __set_iwhat(const int32_t val);

  void __set_swhy(const std::string& val);

  bool operator == (const InvalidIOOperator & rhs) const
  {
    if (!(iwhat == rhs.iwhat))
      return false;
    if (!(swhy == rhs.swhy))
      return false;
    return true;
  }
  bool operator != (const InvalidIOOperator &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InvalidIOOperator & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(InvalidIOOperator &a, InvalidIOOperator &b);

inline std::ostream& operator<<(std::ostream& out, const InvalidIOOperator& obj)
{
  obj.printTo(out);
  return out;
}

} // namespace

#endif
